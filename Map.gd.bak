extends Node
const GenFunc = preload('res://General Functions.gd')
var new_map_pos = Vector2()
var new_cursor_pos = Vector2()
export (PackedScene) var map_node
onready var map = map_node.instance()
onready var map_bounds = round_coords_to_tile(map.get_size(), false)
onready var screen_bounds = get_tree().root.size
onready var absolute_center = screen_bounds/2
onready var map_target = absolute_center
onready var sliding_center = absolute_center
var rel_cursor_pos = absolute_center
var abs_cursor_pos = rel_cursor_pos
var move = Vector2()
var selected_unit
var update_pathfinder = false

func _unit_moves_subfunc(num, pos, movement_type):
    var h = []
    var tiles_first_pass = {}
    var tiles_second_pass = {}
    var tiles_final_pass = {}
    for y in range(-num, num + 1):
        var v = []
        for x in range(-(num - abs(y)) , (num - abs(y))+1):
            v.append(pos + Vector2(x * 16, y * 16))
        h.append(v)
    for x in h:
        for y in x:
            var val = int(num - (abs(y.x - pos.x)/16 + abs(y.y - pos.y)/16))
            if not(val in tiles_first_pass):
                tiles_first_pass[val] = []
            tiles_first_pass[val].append(y)
    for k in tiles_first_pass.keys():
        var v = tiles_first_pass[k]
        for i in v:
            var val = k
            if i != selected_unit.transform.get_origin():
                var cost = (map.get_terrain_cost(movement_type, i)) - 1
                val -= cost
            if not(val in tiles_second_pass.keys()):
                tiles_second_pass[val] = []
            tiles_second_pass[val].append(i)
    var max_val = tiles_second_pass.keys().max()
    for k in range(max_val, -1, -1):
        if k in tiles_second_pass.keys():
            var v = tiles_second_pass[k]
            for tile in v:
                var cost = (map.get_terrain_cost(movement_type, tile))
                var val = k
                var valid = false
                if tile != selected_unit.transform.get_origin():
                    if val + cost in tiles_final_pass.keys():
                        for c in tiles_final_pass[val + cost]:
                            if (c - tile) in [Vector2(-16, 0), Vector2(16, 0), Vector2(0, -16), Vector2(0, 16)]:
                                valid = true
                                break
                    if valid == false:
                        val -= 1
                if val == k:
                    if not(val in tiles_final_pass.keys()):
                        tiles_final_pass[val] = []
                    tiles_final_pass[val].append(tile)
                else:
                    if not(val in tiles_second_pass.keys()):
                        tiles_second_pass[val] = []
                    tiles_second_pass[val].append(tile)
    return tiles_final_pass

func select_unit(pos):
    if rel_cursor_pos == $HUDLayer/Cursor.transform.get_origin() and not selected_unit:
        selected_unit = map.cursor_unit(pos)
        if selected_unit:
            selected_unit.z_index = 5
            selected_unit.path = [selected_unit.transform.get_origin()]
            if len(selected_unit.movement_tiles) == 0:
                selected_unit.movement_tiles = _unit_moves_subfunc(selected_unit.movement, pos, selected_unit.movement_type)
            for k in selected_unit.movement_tiles.keys():
                if k >= 0:
                    for i in selected_unit.movement_tiles[k]: 
                        var tile = $"HUDLayer/Base Movement Tile".duplicate()
                        tile.name = 'Child Tile'
                        tile.transform.origin = i
                        map.get_node('Base Layer').get_node('Move Tiles').add_child(tile)

func deselect_unit():
    if selected_unit:
        for child in map.get_node('Base Layer').get_node('Move Tiles').get_children():
            if 'Child' in child.name:
                map.get_node('Base Layer').get_node('Move Tiles').remove_child(child)
        selected_unit.z_index = 0
        remove_path()
        selected_unit = null

func move_unit(unit, target):
    if not(target in unit.path):
        pathfinder(unit, target)
    unit.target = unit.path[0]
    unit.movement_tiles = {}
    deselect_unit()

func _ready():
    $HUDLayer/Cursor.transform.origin = Vector2(map.left_border, map.top_border)
    rel_cursor_pos = $HUDLayer/Cursor.transform.get_origin()
    add_child(map)
    map_bounds = map.get_size()

func get_tile_coords(location, border = false, rel = false):
    var offset = Vector2()
    if rel:
        offset -= map.transform.get_origin()
    if border:
        offset -= Vector2(map.left_border, map.top_border)
    return ((location + offset)/16).floor()

func round_coords_to_tile(location, border = false, rel = false):
    var offset = Vector2()
    if border:
        offset = Vector2(map.left_border, map.top_border)
    return get_tile_coords(location, border, rel) * 16 + offset

func randomize_array(array):
    return GenFunc.new().randomize_array(array)

func move_center(rel, new_vector):
    if sliding_center == absolute_center:
        var new_map_target = Vector2()
        if rel:
            new_map_target = map_target + new_vector
        else:
            new_map_target = new_vector
        for i in range(2):
            if screen_bounds[i] < map_bounds[i]:
                new_map_target[i] = clamp(new_map_target[i], absolute_center[i], map_bounds[i] - absolute_center[i])
            else:
                new_map_target[i] = absolute_center[i]
        sliding_center += new_map_target - map_target
        map_target = new_map_target

func _pathfinder_subfunc(num: int, moved: Vector2, all_tiles: Array, moved_tiles: Array):
    if num > 0:
        var directions = [Vector2(16, 0), Vector2(-16, 0), Vector2(0, 16), Vector2(0, -16)]
        var order = []
        if abs(moved.x - abs_cursor_pos.x) == abs(moved.y - abs_cursor_pos.y):
            if moved.x - abs_cursor_pos.x < 0:
                order = randomize_array([directions[0], directions[2]]) + randomize_array([directions[1], directions[3]])
            else:
                order = randomize_array([directions[1], directions[3]]) + randomize_array([directions[0], directions[2]])
        elif abs(moved.x - abs_cursor_pos.x) > abs(moved.y - abs_cursor_pos.y):
            if moved.x - abs_cursor_pos.x < 0:
                order = [directions[0]] + randomize_array([directions[2], directions[3]]) + [directions[1]]
            else:
                order = [directions[1]] + randomize_array([directions[2], directions[3]]) + [directions[0]]
        else:
            if moved.y - abs_cursor_pos.y < 0:
                order = [directions[2]] + randomize_array([directions[0], directions[1]]) + [directions[3]]
            else:
                order = [directions[3]] + randomize_array([directions[0], directions[1]]) + [directions[2]]
        for i in order:
            if moved + i in all_tiles and not(moved + i in moved_tiles):
                var temp_moved_tiles = moved_tiles.duplicate()
                var temp_moved = moved
                temp_moved += i
                temp_moved_tiles.append(temp_moved)
                if temp_moved == abs_cursor_pos:
                    moved_tiles = temp_moved_tiles
                    return moved_tiles
                var value = _pathfinder_subfunc(num - map.get_terrain_cost(selected_unit.movement_type, temp_moved), temp_moved, all_tiles, temp_moved_tiles)
                if value != null:
                    return value

func remove_path():
    for child in map.get_children():
        if 'MovementArrows' in child.name:
            map.remove_child(child)

func pathfinder(unit, destination, num = 999):
        var moved = unit.transform.get_origin()
        var all_tiles = []
        var moved_tiles = [unit.transform.get_origin()]
        for k in unit.movement_tiles:
            for v in unit.movement_tiles[k]:
                all_tiles.append(v)
        if destination in all_tiles:
            remove_path()
            var total_cost = 0
            for tile in unit.path:
                total_cost += map.get_terrain_cost(unit.movement_type, tile)
            if len(unit.path) == 0:
                unit.path.append(unit.transform.get_origin())
            #if destination == unit.transform.get_origin():
                #unit.path = []
            if destination in unit.path:
                unit.path = unit.path.slice(0, unit.path.find(destination))
            elif total_cost < unit.movement and (destination - unit.path[-1] in [Vector2(16, 0), Vector2(-16, 0), Vector2(0, 16), Vector2(0, -16)]):
                unit.path.append(destination)
            else:
                unit.path = _pathfinder_subfunc(num, moved, all_tiles, moved_tiles)
            for i in unit.path:
                var tile = $MovementArrows.duplicate()
                var prev
                var next
                if unit.path.find(i) == 0:
                    prev = i - unit.transform.get_origin()
                else:
                    prev = i - unit.path[unit.path.find(i) - 1]
                if i != unit.path[-1]:
                    next = i - unit.path[unit.path.find(i) + 1]
                if unit.path.find(i) == 0:
                    if next == Vector2(-16, 0):
                        tile.frame = 0
                    elif next == Vector2(16, 0):
                        tile.frame = 8
                    elif next == Vector2(0, 16):
                        tile.frame = 7
                    elif next == Vector2(0, -16):
                        tile.frame = 1
                if i == unit.path[-1]:
                    if prev == Vector2(16, 0):
                        tile.frame = 4
                    elif prev == Vector2(-16, 0):
                        tile.frame = 12
                    elif prev == Vector2(0, 16):
                        tile.frame = 5
                    elif prev == Vector2(0, -16):
                        tile.frame = 11
                else:
                    if Vector2(16, 0) in [prev, next] and Vector2(-16, 0) in [prev, next]:
                        tile.frame = 13
                    elif Vector2(0, 16) in [prev, next] and Vector2(0, -16) in [prev, next]:
                        tile.frame = 6
                    elif Vector2(16, 0) in [prev, next] and Vector2(0, 16) in [prev, next]:
                        tile.frame = 10
                    elif Vector2(-16, 0) in [prev, next] and Vector2(0, -16) in [prev, next]:
                        tile.frame = 2
                    elif Vector2(16, 0) in [prev, next] and Vector2(0, -16) in [prev, next]:
                        tile.frame = 3
                    elif Vector2(-16, 0) in [prev, next] and Vector2(0, 16) in [prev, next]:
                        tile.frame = 9
                tile.transform.origin = i
                map.add_child(tile)

func _input(event):
    if event.is_action_pressed("ui_select"):
        if not(selected_unit):
            select_unit(abs_cursor_pos)
        else:
            move_unit(selected_unit, abs_cursor_pos)
    elif event.is_action_pressed("ui_cancel"):
        deselect_unit()
    elif event.is_action_pressed("ui_debug"):
        print(abs_cursor_pos)
    if event is InputEventMouseMotion:
        #moves cursor
        rel_cursor_pos =  round_coords_to_tile(event.position)
        clamp_cursor()
        #allows the camera to scroll if the mouse is near the edge of the screen
        for i in range(2):
            if event.position[i] < 16:
                move[i] = -1
            elif event.position[i] > (screen_bounds[i] - 16):
                move[i] = 1
            else:
                move[i] = 0

func clamp_vector(vector, min_vector, max_vector):
    for i in range(2):
        vector[i] = clamp(vector[i], min_vector[i], max_vector[i])
    return vector

func clamp_cursor():
    rel_cursor_pos = clamp_vector(rel_cursor_pos, map.upper_border + map.transform.get_origin(), screen_bounds - Vector2(16, 16) - map.lower_border + (map.transform.get_origin() + map_bounds - screen_bounds))

func _physics_process(_delta):
    #moving the cursor
    if (Input.is_action_pressed("ui_left") and not Input.is_action_pressed("ui_right")) or move.x == -1:
        new_cursor_pos.x -= 16
    elif Input.is_action_pressed("ui_right") or move.x == 1:
        new_cursor_pos.x += 16
    if (Input.is_action_pressed("ui_up") and not Input.is_action_pressed("ui_down")) or move.y == -1:
        new_cursor_pos.y -= 16
    elif Input.is_action_pressed("ui_down") or move.y == 1:
        new_cursor_pos.y += 16
    if rel_cursor_pos == $HUDLayer/Cursor.transform.get_origin():
        rel_cursor_pos += new_cursor_pos
        clamp_cursor()
        if selected_unit and update_pathfinder == true:
            pathfinder(selected_unit, abs_cursor_pos, selected_unit.movement)
            update_pathfinder = false
    else:
        update_pathfinder = true
    new_cursor_pos = Vector2()
    #moving the camera relative to the map
    if (rel_cursor_pos.x < 16 and map_target.x != absolute_center.x):
        new_map_pos.x = -16
    elif rel_cursor_pos.x + 16 > (screen_bounds.x - 16) and map_target.x != map_bounds.x - absolute_center.x:
        new_map_pos.x = 16
    if rel_cursor_pos.y < 16 and map_target.y != absolute_center.y:
        new_map_pos.y = -16
    elif rel_cursor_pos.y + 16 > (screen_bounds.y - 16) and map_target.y != map_bounds.y - absolute_center.y:
        new_map_pos.y = 16
    if new_map_pos != rel_cursor_pos:
        move_center(true, new_map_pos)
    if sliding_center != absolute_center:
        rel_cursor_pos -= new_map_pos
        sliding_center = sliding_center.move_toward(absolute_center, max(1, sliding_center.distance_to(absolute_center)/16) * 4)
        map.transform.origin = sliding_center - map_target
    new_map_pos = Vector2()
    #code used for the direct movement of the cursor, down here to prevent jittering
    if $HUDLayer/Cursor.transform.get_origin() != rel_cursor_pos:
        $HUDLayer/Cursor.transform.origin = $HUDLayer/Cursor.transform.get_origin().move_toward(rel_cursor_pos, max(4, rel_cursor_pos.distance_to($HUDLayer/Cursor.transform.get_origin())/4))
    #if ($HUDLayer/Cursor.transform.get_origin() == $HUDLayer/Cursor.transform.get_origin()/16 * 16) and update_pathfinder == true:
        #if selected_unit:
            #pathfinder(selected_unit.movement)
        #update_pathfinder = false
    abs_cursor_pos = rel_cursor_pos - map.transform.get_origin()
    for unit in map.get_node('Base Layer').get_node('Units').get_children():
        if unit.target != null:
            unit.transform.origin = unit.transform.get_origin().move_toward(unit.target, 8)
            if unit.transform.get_origin() == unit.target:
                if unit.target == unit.path[-1]:
                    unit.target = null
                else:
                    unit.target = unit.path[unit.path.find(unit.target) + 1]
